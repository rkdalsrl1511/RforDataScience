15장 : 함수
================
huimin
2019 8 3

# 기초 설정

``` r
library(tidyverse)
```

    ## Registered S3 methods overwritten by 'ggplot2':
    ##   method         from 
    ##   [.quosures     rlang
    ##   c.quosures     rlang
    ##   print.quosures rlang

    ## Registered S3 method overwritten by 'rvest':
    ##   method            from
    ##   read_xml.response xml2

    ## -- Attaching packages -------------------------------- tidyverse 1.2.1 --

    ## √ ggplot2 3.1.1       √ purrr   0.3.2  
    ## √ tibble  2.1.1       √ dplyr   0.8.0.1
    ## √ tidyr   0.8.3       √ stringr 1.4.0  
    ## √ readr   1.3.1       √ forcats 0.4.0

    ## -- Conflicts ----------------------------------- tidyverse_conflicts() --
    ## x dplyr::filter() masks stats::filter()
    ## x dplyr::lag()    masks stats::lag()

``` r
library(readr)
library(stringr)
```

# 1\. 들어가기

우선, **파이프의 기능을 담은 패키지에 대한 내용인 14장은 생략**하였다. %T\>%, %$% 등의 기능이 필요하다면,
14장을 참고하라.

함수 작성은 복사하여 붙여넣기에 비해 세 가지 큰 장점이 있다.

  - 연상시키는 이름을 함수에 부여하여 **코드를 이해하기 쉽게 만든다.**
  - 요구사항이 변경되면 여러 곳이 아닌, **한 곳의 코드만 업데이트하면 된다.**
  - 복사하여 붙여넣을 때 **실수 발생의 가능성이 차단된다.**

# 2\. 함수를 언제 작성해야 하나?

코드 블록을 두 번 이상 복사하여 붙여넣을 때마다 함수를 작성하는 것을 고려해야 한다.

함수 생성에는 세 가지 주요 단계가 있다.

  - 함수 이름을 지어야 한다.
  - function 내부에 함수 입력값, 즉 인수를 나열한다. 예를 들어 만약 입력값이 3개라면 function(x, y,
    z)이 된다.
  - 개발한 코드를 함수의 본문(body), 즉 function(…) 다음에 오는 “{” 블록에 넣는다.

**반복하지 말라(Do not repeat yourself, DRY) 원칙**이 있다. 반복을 많이 할수록 상황이 바뀔 때
업데이트를 해야할 장소가 많아지고, 시간이 지나면서 버그를 만들 가능성이 커진다.

# 3\. 함수는 사람과 컴퓨터를 위한 것

사람이 이해할 수 있도록 함수를 작성할 때 함수 이름은 중요하다. 함수의 이름은 짧고, 하는 일은 명확하게 나타내는 것이
이상적이다. 물론 짧은 것보다도 명확해야 한다.

일반적으로 함수 이름은 동사 인수 이름은 명사여야 한다. 물론 예외는 있다. 잘 알려진 함수 이름의 경우(mean같은 경우)에는
명사가 더 좋다.

함수 이름이 여러 단어로 구성된 경우에는 각 소문자 단어를 **언더스코어로 구분하는 스네이크 표기법을 사용하는 것이 좋다.**
물론 어떤 것을 선택하느냐는 중요하지 않지만, **일관성을 유지하는 것은 매우 중요하다.**

가능하면 **기존 함수 및 변수를 덮어쓰지 않는 것이 좋다.**

# 4\. 조건부 실행

if 문을 사용하면 코드를 조건부로 실행할 수 있다. 참고로 if문에 대한 도움말을 알고 싶다면, ?를 입력한 후에
\`\`(역따옴표)안에 if를 넣으면 된다.

``` r
# 백터의 각 요소가 명명 되어 있는지를 논리형 벡터로 반환하는 함수
# 이 함수는 표준 반환 규칙을 이용한다. 마지막으로 계산한 값을 반환한다. 여기서는 if문의 두 갈래 중 하나이다.
has_name <- function(x) {
  
  nms <- names(x)
  
  if (is.null(nms)) { 
    
    rep(FALSE, length(x))
    
  } else {
    
    !is.na(nms) & nms != ""
    
  }
  
}

x <- c(1,2,3,4,5)
has_name(x)
```

    ## [1] FALSE FALSE FALSE FALSE FALSE

``` r
names(x) <- c("1","2","3","4","5")
has_name(x)
```

    ## [1] TRUE TRUE TRUE TRUE TRUE

# 4.1 조건문

조건문은 TRUE와 FALSE로 평가해야 한다. 또한 조건문 안에는 **||와 &&를 사용하여 논리 표현식을 조합할 수 있다.**
||는 첫 TRUE를 보는 즉시 다른 것 계산 없이 TRUE를 반환하고, &&는 FALSE를 처음 보는 즉시, 계산 없이
FALSE를 반환한다.

**헷갈리지 않도록 하자. “|”또는 “&”는 다중값에 적용하는 벡터화 연산이기 때문에 if문에서는 그 대신 “||”와 “&&”를
사용한다.**

또한, if 조건문에서 두 객체가 같은지를 테스트할 때 주의해야 한다. “==”는 벡터화되므로, 출력이 하나 이상이 되기 쉽다.
if 조건문에서는 출력이 한 가지여야 한다. 벡터화되지 않는 엄격한 함수인 **identical을 사용하는 것도 좋다. 항상 단일
TRUE와 FALSE를 반환하며 유형을 강제 변환하지 않는다.**

# 4.2 다중 조건

여러 if문을 함께 연결할 수 있다. 또한, if문이 길게 연속적으로 나타난다면 switch함수를 이용하여 간단하게 나타낼 수
있다.

``` r
# if문 다중 조건
if (FALSE) {
  
} else if(TRUE) {
  
} else {
  
}
```

    ## NULL

``` r
x <- "c"

# switch를 이용한 계산기
calcul.example <- function(x, y, op) {
  
  switch(op,
         plus = x + y,
         minus = x - y,
         times = x * y,
         divide = x / y,
         hello = "hello",
         stop("Unknown op!"))
  
}

calcul.example(1, 2, "plus")
```

    ## [1] 3

cut함수를 활용하여 중첩된 if문을 단순화할 수도 있다. 잠깐 cut함수를 알고 가자.

``` r
x <- 1:10

# breaks에 숫자를 입력하면, 그 숫자만큼의 레벨을 가진 팩터형을 반환한다.
cut(x, breaks = 3)
```

    ##  [1] (0.991,4] (0.991,4] (0.991,4] (0.991,4] (4,7]     (4,7]     (4,7]    
    ##  [8] (7,10]    (7,10]    (7,10]   
    ## Levels: (0.991,4] (4,7] (7,10]

``` r
# labels 인자를 추가할 경우, 레벨의 이름을 임의로 설정할 수 있다.
cut(x, breaks = 2, labels = c("1","2"))
```

    ##  [1] 1 1 1 1 1 2 2 2 2 2
    ## Levels: 1 2

``` r
# breaks에 seq을 사용할 수도 있다.
cut(x, breaks = seq(from = 1, to = 11, by = 2), right = FALSE)
```

    ##  [1] [1,3)  [1,3)  [3,5)  [3,5)  [5,7)  [5,7)  [7,9)  [7,9)  [9,11) [9,11)
    ## Levels: [1,3) [3,5) [5,7) [7,9) [9,11)

# 5\. 함수 인수

함수 인수는 두 가지 종류로 크게 나뉜다. **한 종류는 데이터를 제공하고 다른 종류는 계산의 세부사항을 제어하는 인수를
제공한다.** 예를 들어서,

  - log : 데이터는 x, 세부사항은 로그의 base(밑)이다.
  - mean : 데이터는 x, 세부사항은 양 끝을 얼마나 잘라낼 것인가(trim), 결측값을 어떻게 처리할
    것인가(na.rm)이다.

일반적으로 데이터 인수가 먼저 나온다. 세부사항 인수는 마지막에 있어야 하며, 기본값을 가져야 한다. 기본값은 일반적인 값이어야
한다.

## 5.2 값 확인하기

함수를 많이 작성하다 보면 함수가 정확하게 어떻게 작동하는지 기억하지 못할 수도 있다. 이 시점에서 유효하지 않은 입력으로 함수를
호출하기 쉽다. 이 문제를 피하려면 **제약조건을 명시적으로 나타내는 것이 좋다.**

``` r
# 함수를 만들 때, 중요한 전제조건을 확인하고, 그것이 참이 아니라면 stop을 사용하여 오류를 발생시킨다.
wt_mean <- function(x, w) {
  
  if(length(x) != length(w)) {
    
    stop("'x'와 'w'의 길이가 같아야 한다.", call. = FALSE)
    
  }
  
  sum(w*x) / sum(w)
  
}

# 두 벡터의 길이가 다를 경우 오류를 발생시킨다.
# wt_mean(c(1,2,3), c(5,6))
```

단, 전제 조건을 넣는 방식을 남용할 경우 함수가 복잡해질 수 있다. 그럴 경우에는 **stopifnot함수**를 이용하여
간단하게 처리하는 것이 좋다.

``` r
# na.rm인자를 추가. 기본값은 FALSE이다.
wt_mean <- function(x, w, na.rm = FALSE) {
  
  # 조건문이 참이 아닐 경우, stop한다는 뜻이다.
  stopifnot(is.logical(na.rm), length(na.rm) == 1)
  stopifnot(length(x) == length(w))
  
  # na.rm = TRUE일 경우
  if(na.rm) {
    
    miss <- is.na(x) | is.na(w)
    x <- x[!miss]
    w <- w[!miss]
    
  }
  
  sum(w*x) / sum(w)
  
}

# wt_mean(1:6, 6:1, na.rm = "hello")
```

## 5.3 점-점-점(…)

R 함수 중에는 임의 개수의 입력을 받는 함수가 많다. 이들은 특수 인수 “…”를 사용한다. 이 특수 인수는 매치되지 않는 임의
개수의 인수를 가져온다.

이 “…”는 다른 함수로 보낼 수도 있기 때문에 유용하다.

``` r
# 특수 인수를 활용한 함수
rule <- function(..., pad = "-") {
  
  title <- paste0(...)
  width <- getOption("width") - nchar(title) - 5
  cat(title, " ", stringr::str_dup(pad, width), "\n", sep = "")
  
}

rule("중요한 입력")
```

    ## 중요한 입력 ----------------------------------------------------------------

## 5.4 지연 평가

R의 인수는 **지연 평가(lazy evaluation)**된다. 즉, 필요할 때까지 계산되지 않는다. 사용되지 않는 인수는
호출되지 않는다.

# 6\. 반환값

함수가 무엇을 반환해야 하는지 결정하는 것은 직관적이다. 값을 반환할 때 고려해야 하는 것은 두 가지이다.

  - 반환을 일찍하면 함수 읽기가 쉬워지는가?
  - 함수를 파이핑할 수 있게 만들 수 있는가?

## 6.1 명시적 반환문

return을 사용하여 일찍 반환하도록 선택하는 것이다. 이 책의 저자는 일찍 반환할 수 있다고 알리는 목적에만 return을
사용하는 것을 추천하고 있다. 입력이 빈 경우를 처리하기 위해서이다.

``` r
# return의 예시
complicated_function <- function(x, y, z) {
  
  if(length(x) == 0 | length(y) == 0) {
    
    return(0)
    
  }
  
}
```

## 6.2 파이핑 가능한 함수 작성

반환값에 대해 생각하는 게 중요하다. 반환값 객체 유형을 알면 파이프라인이 작동은 할 것이다. 파이핑 가능한 함수에는 변환과
부수효과라는 두 가지 기본 유형이 있다.

**변환 함수**에서는 객체가 함수의 첫 번째 인수로 전달되고 수정된 객체가 반환된다.

**부수효과 함수**에서는 전달된 객체가 변환되지 않는다. 대신, 함수가 플롯을 그리거나 파일을 저장하는 것과 같은 동작을 주어진
객체에 수행한다. 부수효과 함수는 첫 번째 인수가 출력되지 않지만 파이프라인에서 사용될 수 있도록 “보이지 않게” 반환해야 한다.

예를 들어 다음의 간단한 함수는 데이터프레임의 결측값 개수를 출력한다.

``` r
# 대화식으로 출력하면 invisible은 입력된 df를 출력하지 않음을 의미한다.
show_missings <- function(df) {
  
  n <- sum(is.na(df))
  cat("Missing values: ", n, "\n", sep = "")
  
  invisible(df)

}

show_missings(mtcars)
```

    ## Missing values: 0

``` r
# 반환값은 여전히 존재한다. 기본값으로 출력되지 않을 뿐이다.
x <- show_missings(mtcars)
```

    ## Missing values: 0

``` r
class(x)
```

    ## [1] "data.frame"

``` r
dim(x)
```

    ## [1] 32 11

``` r
# 그리고 파이프에서 사용할 수 있다.
mtcars %>% 
  show_missings() %>% 
  dplyr::mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>% 
  show_missings()
```

    ## Missing values: 0
    ## Missing values: 18

# 7\. 환경

함수가 작동하는 방식과 관련하여 중요한 요소이다. 함수의 환경은 R이 이름과 연관된 값을 찾는 방법을 결정한다. 이건 조금 더
공학적인 프로그래밍과 연관된 내용으로, 외부 변수와 내부 변수 등과 관련된다. 당연히 난 기초적인 프로그래밍의 개념을 알고
있기 때문에 생략한다.
